<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>7&nbsp; Experiment setup – The statistics of online experiments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/lemmas.html" rel="next">
<link href="../chapters/threats_to_validity.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../custom.scss">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/experiment_setup.html"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Experiment setup</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">The statistics of online experiments</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Setup</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/experiments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Experiments</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/stats_of_online_experiments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">The stats of online experiments</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/hypothesis_testing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Hypothesis testing</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/power.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Power</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/threats_to_validity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Threats to validity</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/experiment_setup.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Experiment setup</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/lemmas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Lemmas</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/stats_foundations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Statistics foundations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/faqs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">FAQs</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#approaches-to-analysing-bres-sampling-vs-design-based" id="toc-approaches-to-analysing-bres-sampling-vs-design-based" class="nav-link active" data-scroll-target="#approaches-to-analysing-bres-sampling-vs-design-based"><span class="header-section-number">7.1</span> Approaches to analysing BREs – sampling vs design based</a></li>
  <li><a href="#finite-sample-vs-superpopulation-analysis" id="toc-finite-sample-vs-superpopulation-analysis" class="nav-link" data-scroll-target="#finite-sample-vs-superpopulation-analysis"><span class="header-section-number">7.2</span> Finite sample vs superpopulation analysis</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-experiment-setup" class="quarto-section-identifier"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Experiment setup</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In the main text, I refer to this file three times: 1) Decision between finite sample vs super population 2) Decision between CRE or BRE – settled by how we randomise in online experiments 3) Decision how to analyse BRE – condition on n or treat n as binomial variable (former: easier and corresponds to situation at time of analysis</p>
<p>todo: - See chat discussion - See here: https://alexdeng.github.io/causal/randomintro.html (exactly what I want) - Generally, literature uses a potential outcome framework - <span class="citation" data-cites="larsen2023statistical">Larsen et al. (<a href="references.html#ref-larsen2023statistical" role="doc-biblioref">2023</a>)</span> - Some vendors/literature assume fixed sample sizes - <span class="citation" data-cites="nordin2024precision">Nordin and Schultzberg (<a href="references.html#ref-nordin2024precision" role="doc-biblioref">2024</a>)</span> - Others use an iid framework for motivation - zhou2023all</p>
<ul>
<li>Incorporate:
<ul>
<li>Two entities to view as either fixed or random:
<ul>
<li>Potential outcomes (Sampling perspective?)
<ul>
<li>wager2024causal</li>
<li>ding2023first footnote 1 on page 25</li>
</ul></li>
<li>Sample sizes (BRE vs CRE)</li>
</ul></li>
<li>Focus can be on super population or finite sample
<ul>
<li>Argue that in contexts of A/B tests this doesn’t make sense, since population is well defined. But understand what implications are.</li>
<li>li2017general beginning of intro discusses this</li>
</ul></li>
</ul></li>
</ul>
<section id="approaches-to-analysing-bres-sampling-vs-design-based" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="approaches-to-analysing-bres-sampling-vs-design-based"><span class="header-section-number">7.1</span> Approaches to analysing BREs – sampling vs design based</h2>
<ul>
<li><p>Sampling vs randomisation based – see [[stats_foundations#Modes of inference]]</p></li>
<li><p>Reading Wager, it seems there are two relevant factors for inference: he just conditions on n to get a CRE, and then there is the question of whether to take a finite sample or super-population perspective.</p></li>
<li><p>The additional assumption (discussed in population asymptotics) of random sampling from super population holds for online experiments.</p></li>
<li><p>He does use Bernoulli sampling, which is what I need for online experiments. I just don’f fully understand how his perspective fits into the Imbens Rubin book / Athey Imbens one.</p></li>
<li><p>See Ding book</p></li>
</ul>
</section>
<section id="finite-sample-vs-superpopulation-analysis" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="finite-sample-vs-superpopulation-analysis"><span class="header-section-number">7.2</span> Finite sample vs superpopulation analysis</h2>
<ul>
<li><p>First, we decide whether the <span class="math inline">\(n\)</span> units in our experiment sample are the population of interest, or whether that population of interest is instead a larger super-population of size <span class="math inline">\(N\)</span> of which the <span class="math inline">\(n\)</span> units in the experiment sample are a random sample. Following <span class="citation" data-cites="imbens2015causal">Imbens and Rubin (<a href="references.html#ref-imbens2015causal" role="doc-biblioref">2015</a>)</span>, I refer to the former as the finite sample perspective and the later as the super population perspective.</p></li>
<li><p>Online experiments typically go through a ramp-up phase: they include only a small fraction of users at the start and all users at the end.</p></li>
</ul>
<p>Below is from an old version – I don’t actually consider both. Just discuss difference here. Use material from imbens2015causal to point out that, ultimately, the difference is irrelevant in practice.</p>
<ul>
<li><p>Statistically, this means we have to consider two different cases. In the first case, during the early stages of an experiment, we use a sample of the entire user population to learn something about that population as a whole; in this case, the sample we work with and the sample we want to learn something about are different. In the second case, when the entire user population is part of the experiment, the sample we work with and the sample we want to learn something about are the same. Following <span class="citation" data-cites="imbens2015causal">Imbens and Rubin (<a href="references.html#ref-imbens2015causal" role="doc-biblioref">2015</a>)</span>, I refer to the first approach as the super-population perspective and the second case the finite sample perspective.</p></li>
<li><p>We have a super population of <span class="math inline">\(N\)</span> users. In the example I’m going to use throughout, these are all of our iOS-app users in the UK.</p></li>
<li><p>From this super population, we sample <span class="math inline">\(n\)</span> users to be part of the experiment, and then allocate <span class="math inline">\(n_t\)</span> users to treatment and <span class="math inline">\(n_c\)</span> users to control.</p></li>
<li><p>The way we sample users into the experiment and allocate them to treatment has implications for our statistical analysis, so let’s have a look at the details.</p></li>
<li><p>Online experiments typically use the following <strong>sampling</strong> approach to determine whether a user is part of an experiment:</p>
<ol type="1">
<li>Create a hash string unique for each user in the experiment such as <code>&lt;user_id&gt;&lt;experiment_id&gt;&lt;market&gt;</code>.<br>
</li>
<li>Feed the hash string into a hash algorithm (often MD5) and receive a hash value.</li>
<li>Use the hash value to determine whether a user is part of the experiment. Say we allocate 10% of traffic to the experiment. We then include the user only if their hash value falls within the bottom (or top) 10% of possible hash values.</li>
</ol></li>
<li><p>With this approach, the probability that a user is sampled into the experiment is independent of the sampling decisions of all other users.</p></li>
<li><p>We write <span class="math inline">\(R_i = 1\)</span> if user <span class="math inline">\(i\)</span> is part of the experiment sample and <span class="math inline">\(R_i = 0\)</span> if they aren’t.</p></li>
<li><p>If we sample <span class="math inline">\(n\)</span> users into the experiment, then each of our <span class="math inline">\(N\)</span> users is part of the experiment experiment with probability <span class="math inline">\(n/N\)</span>.</p></li>
<li><p>For each user in the super population, being part of the experiment sample is a <a href="https://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli trial</a> with <span class="math inline">\(R_i \sim \text{Bernoulli}(n/N)\)</span> and, hence, <span class="math inline">\(\mathbb{E}[R_i] = n/N\)</span> and <span class="math inline">\(\mathbb{V}(R_i) = n/N(1-n/N)\)</span>. I assume here that we know <span class="math inline">\(n\)</span>. The reason for doing so is twofold. First, it makes the math easier as it spares us from modeling <span class="math inline">\(n\)</span> as a Binomial random variable. Second, by the time we analyse the data, we do know <span class="math inline">\(n\)</span>.</p></li>
</ul>
<section id="description" class="level4" data-number="7.2.0.1">
<h4 data-number="7.2.0.1" class="anchored" data-anchor-id="description"><span class="header-section-number">7.2.0.1</span> Description</h4>
<p>From athey2017econometrics</p>
<p>Super population perspective:</p>
<ul>
<li><p>Traditionally, uncertainty in empirical analysis is viewed as arising from randomly drawing a sample of size <span class="math inline">\(n\)</span> from an infinitely large super-population of size <span class="math inline">\(N\)</span>.</p></li>
<li><p>(Infinite probably out of convenience so math is easier. Check if ever relevant or when I have time.)</p></li>
<li><p>For example, it we could measure the height of every single person in London there would be no uncertainty about the average height of that population.</p></li>
</ul>
<p>Finite sample perspective</p>
<ul>
<li><p>When we perform causal inference studies, however, then there are many contexts where the above perspective is odd because we have the entire population to work with so that it’s not clear what the super-population is.</p></li>
<li><p>For instance, an online experiment with an audience traffic of 100% has got the entire population of customers.</p></li>
<li><p>In such a setting, however, thinking of causal effects as the difference in individual potential outcomes allows us to interpret the randomness as coming from treatment allocation.</p></li>
</ul>
</section>
<section id="notes-on-super-population-perspective" class="level4" data-number="7.2.0.2">
<h4 data-number="7.2.0.2" class="anchored" data-anchor-id="notes-on-super-population-perspective"><span class="header-section-number">7.2.0.2</span> Notes on super-population perspective</h4>
<p>todo: - Is it worth considering SP case? As in, do we have to adjust the standard error? How much do SEs differ in practice?</p>
<ul>
<li>How to go about this: 1) establish whether or not super-population approach is required, 2) is so, compare FS and SP standard errors to check whether it makes a difference. Write up regardless to have a good theoretical foundation. But if I’m lucky then using SP SEs makes a material difference in practice, in which case this would be interesting to publish and use at work.</li>
</ul>
<p>Notes:</p>
<ul>
<li><p>So far, we have focused on the case where the <span class="math inline">\(n\)</span> units in the experiment sample are the population of interest.</p></li>
<li><p>Online experiments typically go through a ramp-up phase: they include only a small fraction of users at the start and all users at the end.</p></li>
<li><p>Statistically, this means we have to consider two different cases. In the first case, during the early stages of an experiment, we use a sample of the entire user population to learn something about that population as a whole; in this case, the sample we work with and the sample we want to learn something about are different. In the second case, when the entire user population is part of the experiment, the sample we work with and the sample we want to learn something about are the same. Following <span class="citation" data-cites="imbens2015causal">Imbens and Rubin (<a href="references.html#ref-imbens2015causal" role="doc-biblioref">2015</a>)</span>, I refer to the first approach as the super-population perspective and the second case the finite sample perspective.</p></li>
<li><p>We have a (super) population of <span class="math inline">\(N\)</span> users. In the example I’m going to use throughout, these are all of our iOS-app users in the UK.</p></li>
<li><p>From this super population, we sample <span class="math inline">\(n\)</span> users to be part of the experiment, and then allocate <span class="math inline">\(n_t\)</span> users to treatment and <span class="math inline">\(n_c\)</span> users to control.</p></li>
<li><p>The way we sample users into the experiment and allocate them to treatment has implications for our statistical analysis, so let’s have a look at the details.</p></li>
<li><p>Online experiments usually use the following <strong>sampling</strong> approach to determine whether a user is part of an experiment:</p>
<ol type="1">
<li><p>Create a hash string unique to each user such as <code>&lt;user_id&gt;&lt;experiment_id&gt;&lt;market&gt;</code>.</p></li>
<li><p>Feed the hash string into a hash algorithm (often MD5) and receive a hash value.</p></li>
<li><p>Use the hash value to determine whether a user is part of the experiment. Say we allocate 10% of traffic to the experiment. We then include the user only if their hash value falls within the bottom (or top) 10% of possible hash values.</p></li>
</ol></li>
<li><p>With this approach, the probability that a user is sampled into the experiment is independent of the sampling decisions of all other users.</p></li>
<li><p>Each of our <span class="math inline">\(N\)</span> users is part of the experiment experiment with probability <span class="math inline">\(n/N\)</span> and we write <span class="math inline">\(R_i = 1\)</span> if user <span class="math inline">\(i\)</span> is part of the experiment sample and <span class="math inline">\(R_i = 0\)</span> if they aren’t. Note that I take <span class="math inline">\(n\)</span> as given here. For each user in the super population, being part of the experiment sample is a <a href="https://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli trial</a> with <span class="math inline">\(R_i \sim \text{Bernoulli}(n/N)\)</span> and, hence, <span class="math inline">\(\mathbb{E}[{R_i}] = n/N\)</span> and <span class="math inline">\(\mathbb{V}(R_i) = n/N(1-n/N)\)</span>. I assume here that we know <span class="math inline">\(n\)</span>. The reason for doing so is twofold. First, it makes the math easier as it spares us from modeling <span class="math inline">\(n\)</span> as a Binomial random variable. Second, by the time we analyse the data, we do know <span class="math inline">\(n\)</span>.</p></li>
<li><p>For each user in the super population, being part of the experiment sample is a <a href="https://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli trial</a>, as is being part of the treatment group for each user in the experiment sample. <span class="math display">\[
\begin{align}
R_i \sim \text{Bernoulli}(p) \quad &amp;\text{with} \quad \mathbb{E}[R_i] = p \\
W_i \sim \text{Bernoulli}(q) \quad &amp;\text{with} \quad \mathbb{E}[W_i] = q
\end{align}
\]</span></p></li>
<li><p>The total number of users in the sample is <span class="math inline">\(n = \sum_{i = 1}^{N}R_i\)</span>.</p></li>
<li><p>Each of the <span class="math inline">\(n\)</span> users in our sample is allocated to the treatment condition with probability <span class="math inline">\(q\)</span>, and we write <span class="math inline">\(W_i = 1\)</span> if user <span class="math inline">\(i\)</span> is in the treatment group and <span class="math inline">\(W_i = 0\)</span> if they are in the control group.</p></li>
<li><p>The total number of users in the treatment group is <span class="math inline">\(n_t = \sum_{i = 1}^{N} W_i\)</span>, and the total number of users in the control group is <span class="math inline">\(n_c = \sum_{i = 1}^{N} (1 - W_i)\)</span>.</p></li>
<li><p>Given this setup, we have: <span class="math display">\[
\begin{align}
\mathbb{E}[R_i] &amp;= p \\
\mathbb{E}[W_i] &amp;= q \\
\mathbb{E}[n] &amp;= Np \\
\mathbb{E}[n_t] &amp;= nq \\
\mathbb{E}[n_c] &amp;= n(1 - q) \\
\end{align}
\]</span></p>
<p>(we will use this in the unbiasedness proof below)</p></li>
<li><p>Compare this to a setup where treatment allocation is-non independent: This is easiest to see in contrast to experiments where neither of these decisions are independent, as is often the case in lab and field experiments in social science, but also medical experiments. There, we typically recruit a pre-determined number of units into our experiment, so that the inclusion of any given unit lowers the probability of inclusion for all others. Similarly, for treatment assignment, we would often use a completely randomised assignment, whereby we ensure that exactly <span class="math inline">\(N_t\)</span> units end up in the treatment group. This, again means that assigning any given unit to treatment lowers the probability of receiving the treatment for all other units.</p></li>
</ul>
<p><strong>Super population Estimator</strong></p>
<ul>
<li><p>A natural estimator is …</p></li>
<li><p>We can write our treatment effect estimator, <span class="math inline">\(\hat{\tau}\)</span> in terms of the super-population as</p></li>
</ul>
<p><span class="math display">\[
\hat{\tau} = \frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i - \frac{1}{n_c}\sum_{i=1}^{N} R_i (1 - W_i) Y_i
\]</span></p>
<p><strong>Unbiasedness of <span class="math inline">\(\hat{\tau}\)</span></strong></p>
<ul>
<li><p>Use derivation in wager2024causal page 6, which is very transparent!</p></li>
<li><p>First, note that using <!-- @eq-yi  --></p></li>
</ul>
<p>we can write:</p>
<p><span class="math display">\[
\begin{align}
\frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i &amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i(1) \\
\frac{1}{n_c}\sum_{i=1}^{N} R_i (1 - W_i) Y_i &amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i(1 - W_i) Y_i(0)
\end{align}
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Derivation</p>
<p><span class="math display">\[
\begin{align}
\frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i W_i \Bigl(W_i Y_i(1) + (1 - W_i) Y_i(0)\Bigr) \\
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} \Bigl(R_i W_i W_i Y_i(1) + R_i W_i (1 - W_i) Y_i(0)\Bigr) \\
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i W_i W_i Y_i(1) \\
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i(1) \\
\frac{1}{n_c}\sum_{i=1}^{N} R_i (1 - W_i) Y_i
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i (1 - W_i) \Bigl(W_i Y_i(1) + (1 - W_i) Y_i(0)\Bigr) \\
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} \Bigl(R_i(1 - W_i) W_i Y_i(1) + R_i(1 - W_i) (1 - W_i) Y_i(0)\Bigr) \\
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i(1 - W_i) (1 - W_i) Y_i(0) \\
&amp;= \frac{1}{n_t}\sum_{i=1}^{N} R_i(1 - W_i) Y_i(0)
\end{align}
\]</span></p>
</div>
</div>
</div>
<ul>
<li><p>We can now show that <span class="math inline">\(\hat{\tau}\)</span> in unbiased, that <span class="math inline">\(\mathbb{E}[\hat{\tau}] = \tau\)</span>.</p></li>
<li><p>We have two sources of randomness, one due to random sampling and one due to random allocation to treatment. Using the law of iterated expectations, we can write:</p></li>
</ul>
<p><span class="math display">\[
\mathbb{E}[\hat{\tau}] = \mathbb{E}_{sp}[\mathbb{E}_W{\hat{\tau}|R}]].
\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Law of iterated expectations</p>
<ul>
<li>That is, we can first take the expectation over the randomisation distribution while talking the vector of sampling allocation indicators, <span class="math inline">\(R\)</span>, as given, and then take the expectation over the sampling distribution. <span class="math display">\[
\begin{align}
...
\end{align}
\]</span></li>
</ul>
</div>
</div>
</div>
<ul>
<li><p>In both of these steps, we implicitly also condition on the vectors of potential outcomes in the super population, <span class="math inline">\(Y_{sp}(0), Y_{sp}(1)\)</span>, which we consider fixed and take as given. I don’t condition on these explicitly to keep the notation light.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
<li><p>TODO: condition on <span class="math inline">\(Y\)</span>, as a shorthand. Adapt notation below. Also, consider using bf for vectors and matrices for clarity. Probably do it!</p></li>
<li><p>The inner expectation is equal to:</p></li>
</ul>
<p><span class="math display">\[
\begin{align}
\EW{\hat{\tau} | R}
&amp;= \EW{\frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i - \frac{1}{n_c}\sum_{i=1}^{N} R_i (1 - W_i) Y_i \&gt;\Bigg|\&gt; R} \vs
&amp;= \EW{\frac{1}{n_t}\sum_{i=1}^{N} R_i W_i Y_i(1) - \frac{1}{n_c}\sum_{i=1}^{N} R_i (1 - W_i) Y_i(0) \&gt;\Bigg|\&gt; R} \vs
&amp;= \EW{\sum_{i=1}^{N} R_i \Biggl(\frac{W_i Y_i(1)}{n_t} - \frac{(1 - W_i) Y_i(0)}{n_c}\Biggr)\&gt;\Bigg|\&gt; R} \vs
&amp;= \sum_{i=1}^{N} R_i \EW{\frac{W_i Y_i(1)}{n_t} - \frac{(1 - W_i) Y_i(0)}{n_c}} \vs
&amp;= \sum_{i=1}^{N} R_i \Biggl(\frac{\EW{W_i} Y_i(1)}{\EW{n_t}} - \frac{(1 - \EW{W_i}) Y_i(0)}{\EW{n_c}}\Biggr) \vs
&amp;= \sum_{i=1}^{N} R_i \Biggl(\frac{q Y_i(1)}{Nq} - \frac{(1 - q) Y_i(0)}{N(1-q)}\Biggr) \vs
&amp;= \sum_{i=1}^{N} R_i \Biggl(\frac{Y_i(1)}{N} - \frac{Y_i(0)}{N}\Biggr) \vs
&amp;= \frac{1}{N}\sum_{i=1}^{N} R_i \bigl(Y_i(1) - Y_i(0)\bigr) \vs
&amp;= \tau_{fs}
\end{align}
\]</span></p>
<ul>
<li>The outer expectation is equal to:</li>
</ul>
<p><span class="math display">\[
\begin{align}
\mathbb{E}[\hat{\tau}]
&amp;= \Esp{\EW{\hat{\tau}|R}} \\
&amp;= \Esp{\tau_{fs}} \\
&amp;= \Esp{\frac{1}{N}\sum_{i=1}^{N} R_i \bigl(Y_i(1) - Y_i(0)\bigr)} \\
&amp;= \frac{1}{\Esp{N}}\sum_{i=1}^{N} \Esp{R_i} \bigl(Y_i(1) - Y_i(0)\bigr) \\
&amp;= \frac{1}{Np}\sum_{i=1}^{N} p \bigl(Y_i(1) - Y_i(0)\bigr) \\
&amp;= \frac{1}{N}\sum_{i=1}^{N}\bigl(Y_i(1) - Y_i(0)\bigr) \\
&amp;= \tau
\end{align}
\]</span></p>
<p><strong>Variance of <span class="math inline">\(\hat{\tau}\)</span></strong></p>
<ul>
<li>Using the law of total variance<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, we can write <span class="math inline">\(\V{\hat{\tau}}\)</span> as</li>
</ul>
<p><span class="math display">\[
\begin{align}
\V{\hat{\tau}}
&amp;= \Esp{\VW{\hat{\tau} | R}} + \Vsp{\EW{\hat{\tau} | R}}
\end{align}
\]</span></p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-imbens2015causal" class="csl-entry" role="listitem">
Imbens, Guido W, and Donald B Rubin. 2015. <em>Causal Inference in Statistics, Social, and Biomedical Sciences</em>. Cambridge University Press.
</div>
<div id="ref-larsen2023statistical" class="csl-entry" role="listitem">
Larsen, Nicholas, Jonathan Stallrich, Srijan Sengupta, Alex Deng, Ron Kohavi, and Nathaniel T Stevens. 2023. <span>“Statistical Challenges in Online Controlled Experiments: A Review of a/b Testing Methodology.”</span> <em>The American Statistician</em>, 1–15.
</div>
<div id="ref-nordin2024precision" class="csl-entry" role="listitem">
Nordin, Mattias, and Mårten Schultzberg. 2024. <span>“Precision-Based Designs for Sequential Randomized Experiments.”</span> <em>arXiv Preprint arXiv:2405.03487</em>.
</div>
</div>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>If we were to explicitly condition on potential outcomes, we’d get: <span class="math display">\[
  \begin{align}
  \mathbb{E}[\hat{\tau}]
  &amp;=\Esp{\EW{\hat{\tau}|R, Y_{sp}(0), Y_{sp}(1)} | Y_{sp}(0), Y_{sp}(1)}
  \end{align}
  \]</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>In general, the <a href="https://en.wikipedia.org/wiki/Law_of_total_variance">Law of total variance</a> states that: <span class="math display">\[
  \begin{align}
  \V{Y} = \mathbb{E}[\V{Y|X}] + \V{\mathbb{E}[Y|X}]
  \end{align}
  \]</span> In our case here, conditioning on <span class="math inline">\(R\)</span> means that we take the expectation or variance over the randomisation distribution, which I make explicit with the subscript <span class="math inline">\(W\)</span>. The unconditional expectation or variance is taken over the randomisation distribution, which I make explicit using the subscript <span class="math inline">\(sp\)</span>. As in the unbiasedness proof above, we are also implicitly conditioning on potential outcomes and I omit making this explicit to keep the notation lighter. Making the conditioning explicit would mean we apply the law to a conditional variance, for which the logic would still hold, and we’d write: <span class="math display">\[
  \begin{align}
  \V{\hat{\tau} | Y_{sp}(0), Y_{sp}(1)}
  &amp;= \Esp{\VW{\hat{\tau} | R, Y_{sp}(0), Y_{sp}(1)} | Y_{sp}(0), Y_{sp}(1)} \\
  &amp;+ \Vsp{\EW{\hat{\tau} | R, Y_{sp}(0), Y_{sp}(1)} | Y_{sp}(0), Y_{sp}(1)}
  \end{align}
  \]</span><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/threats_to_validity.html" class="pagination-link" aria-label="Threats to validity">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Threats to validity</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/lemmas.html" class="pagination-link" aria-label="Lemmas">
        <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Lemmas</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>